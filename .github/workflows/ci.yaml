on:
  pull_request: 
    branches:
      - main
  push:
    branches:
      - main

name: Continuous integration

env:
  BASE_IMAGE_NAME: livegrep/base
  INDEXER_IMAGE_NAME: livegrep/indexer
  NGINX_IMAGE_NAME: livegrep/nginx

jobs:
  build-and-test-livegrep:
    # Running this in matrix means that bazel will upload build artifcats for 
    # all listed platforms to the remote cache. This should allow more local 
    # developers to use the remote cache to get started. Windows support can be 
    # added if necessary, assuming for now the windows usage rate would be low
    # enough that it's not worth the CI time to build for it.

    strategy:
      matrix:
        platform: [ubuntu-20.04, macos-latest]
    runs-on: ${{ matrix.platform }}
    outputs:
      build_output_file_name: ${{ steps.build.outputs.build_output_file_name }}
    steps:
      - uses: actions/checkout@v2
      - name: Switch to CI bazelrc
        run: cp .bazelrc.ci .bazelrc
      # Credit to the tensorboard repo for the cache configuration step 
      # https://github.com/tensorflow/tensorboard/blob/master/.github/workflows/ci.yml#L58
      # Plenty of ways to do something similar but I really liked theirs
      - name: 'Configure remote build cache usage'
        env:
          GCP_CREDS: ${{ secrets.GCP_SVC_ACCT_CREDS }}
          EVENT_TYPE: ${{ github.event_name }}
        run: |
          if [ -z "${GCP_CREDS}" ]; then
            printf 'Using read-only cache (no credentials)\n'
            exit
          fi
          if [ "${EVENT_TYPE}" = pull_request ]; then
            printf 'Using read-only cache (PR build)\n'
            exit
          fi
          printf 'Using writable cache\n'
          creds_file=/tmp/svc_acct_creds.json
          printf '%s\n' "${GCP_CREDS}" >"${creds_file}"
          printf '%s\n' >>~/.bazelrc \
            "common --google_credentials=${creds_file}" \
            "common --remote_upload_local_results=true" \
            ;
        # need this step because with use sha256 sum durin bazel builds,
        # which isn't available by default in macOS
      - name: Install coreutils for macOS
        if: matrix.os == 'macOS-latest'
        run: brew install coreutils
      - name: bazel fetch
        run: bazel fetch //cmd/...
      - name: gofmt
        run: |
          gofmt=$(bazel info output_base)/external/go_sdk/bin/gofmt
          format_errors=$(find . -name '*.go' -print0 | xargs -0 "$gofmt" -l -e)
          if [ "$format_errors" ]; then
              echo "=== misformatted files (run gofmt) ==="
              echo "$format_errors"
              exit 1
          fi
      - name: bazel build
        id: build
        run: |
          bazel test --test_arg=-test.v //...
          bazel build //...
          echo "build_output_file_name=$(./package.sh)" >> $GITHUB_ENV
          echo "::set-output name=build_output_file_name::${build_output_file_name}"
      - name: bazel test
        run: bazel test --test_arg=-test.v //...
      - name: upload build output
        if: ${{ github.event_name == 'push' }}
        uses: actions/upload-artifact@v2
        with: 
          name: "${{ env.build_output_file_name }}"
          path: "builds/${{ env.build_output_file_name }}.tgz"
          retention-days: 1
          
  create-and-push-images-to-ghcr:
    if: ${{ github.event_name == 'push' }}
    runs-on: ubuntu-20.04
    needs: [build-and-test-livegrep]
    steps:
      - name: Build images
        run: |
          docker build -t $BASE_IMAGE_NAME --file docker/base/Dockerfile --build-arg "livegrep_version=${{needs.build-and-test-livegrep.outputs.build_output_file_name}}"  .
          docker build -t $INDEXER_IMAGE_NAME . --file docker/indexer/Dockerfile
          docker build -t $NGINX_IMAGE_NAME . --file docker/nginx/Dockerfile
      - name: Push images
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          
          BASE_IMAGE_ID=ghcr.io/${{ github.repository_owner }}/$BASE_IMAGE_NAME
          INDEXER_IMAGE_ID=ghcr.io/${{ github.repository_owner }}/$INDEXER_IMAGE_NAME
          NGINX_IMAGE_ID=ghcr.io/${{ github.repository_owner }}/$NGINX_IMAGE_NAME

          # tag each image with GHCRID:VERSION
          VERSION=$(git rev-parse HEAD | head -c10)
          docker tag $BASE_IMAGE_NAME $BASE_IMAGE_ID:$VERSION
          docker tag $INDEXER_IMAGE_NAME $INDEXER_IMAGE_ID:$VERSION
          docker tag $NGINX_IMAGE_NAME $NGINX_IMAGE_ID:$VERSION

          # this workflow is running on "main" atm so always tag latest
          docker tag $BASE_IMAGE_NAME $BASE_IMAGE_ID:latest
          docker tag $INDEXER_IMAGE_NAME $INDEXER_IMAGE_ID:latest
          docker tag $NGINX_IMAGE_NAME $NGINX_IMAGE_ID:latest
          
          docker push $NGINX_IMAGE_ID:$VERSION
          docker push $BASE_IMAGE_ID:$VERSION
          docker push $INDEXER_IMAGE_ID:$VERSION

          # it seems like docker doesn't push all tags for an image, you need to
          # push each tag as if it were a seperate image -__-
          echo "Pushing latest images to test"
          docker push $NGINX_IMAGE_ID:latest
          docker push $BASE_IMAGE_ID:latest
          docker push $INDEXER_IMAGE_ID:latest
