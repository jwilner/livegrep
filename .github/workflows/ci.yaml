on:
  pull_request: 
    branches:
      - main
  push:
    branches:
      - main

name: Continuous integration

env:
  BASE_IMAGE_NAME: xvandish-livegrep/base
  INDEXER_IMAGE_NAME: xvandish-livegrep/indexer
  NGINX_IMAGE_NAME: xvandish-livegrep/nginx

# https://github.com/actions/runner/issues/1039 - GITHUB_TOKEN works only for the main branch
# so it won't work for the pull_requests. Just use a PAT then 
jobs:
  ci:
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v2
      - uses: actions/cache@v2
        with:
          path: ~/.cache/bazel
          key: ${{runner.os}}-${{hashFiles('WORKSPACE')}}
          restore-keys: |
            ${{runner.os}}-
      - name: setup bazel
        run: |
          cat .bazelrc.ci >> .bazelrc
      - name: bazel fetch
        run: |
          bazel fetch //cmd/...
      - name: gofmt
        run: |
          gofmt=$(bazel info output_base)/external/go_sdk/bin/gofmt
          format_errors=$(find . -name '*.go' -print0 | xargs -0 "$gofmt" -l -e)
          if [ "$format_errors" ]; then
              echo "=== misformatted files (run gofmt) ==="
              echo "$format_errors"
              exit 1
          fi
      - name: bazel build and test
        env: 
          GCP_CREDS: ${{ secrets.GCP_SVC_ACCT_CREDS }}
        run: |
          printf '%s\n' "${GCP_CREDS}" >service_account_creds.json
          if [[ "${EVENT_NAME}" == "push" && "${REPO_NAME}" == "xvandish/livegrep" ]]; then
            BAZEL_OPTIMIZATION="--remote_cache=https://storage.googleapis.com/livegrep-bazel-remote-cache --remote_upload_local_results=true --google_credentials=service_account_creds.json"
          else
            BAZEL_OPTIMIZATION="--remote_cache=https://storage.googleapis.com/livegrep-remote-cache --remote_upload_local_results=false"
          fi
          bazel build $BAZEL_OPTIMIZATION //...  
          bazel test $BAZEL_OPTIMIZATION --test_arg=-test.v //...
          echo "build_output_file_name=$(./package.sh)" >> $GITHUB_ENV
      - name: upload build output
        uses: actions/upload-artifact@v2
        with: 
          name: "${{ env.build_output_file_name }}"
          path: "builds/${{ env.build_output_file_name }}.tgz"
      - name: Build images
        run: |
          # the first image is tagged because subsequent images build from it
          docker build -t $BASE_IMAGE_NAME --file docker/base/Dockerfile --build-arg "livegrep_version=$build_output_file_name"  .
          docker build -t $INDEXER_IMAGE_NAME . --file docker/indexer/Dockerfile
          docker build -t $NGINX_IMAGE_NAME . --file docker/nginx/Dockerfile
      - name: Push images
        run: |
          echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          
          BASE_IMAGE_ID=ghcr.io/${{ github.repository_owner }}/$BASE_IMAGE_NAME
          INDEXER_IMAGE_ID=ghcr.io/${{ github.repository_owner }}/$INDEXER_IMAGE_NAME
          NGINX_IMAGE_ID=ghcr.io/${{ github.repository_owner }}/$NGINX_IMAGE_NAME

          # same version as made by package.sh
          VERSION=$(git rev-parse HEAD | head -c10)
          docker tag $BASE_IMAGE_NAME $BASE_IMAGE_ID:$VERSION
          docker tag $INDEXER_IMAGE_NAME $INDEXER_IMAGE_ID:$VERSION
          docker tag $NGINX_IMAGE_NAME $NGINX_IMAGE_ID:$VERSION

          # we add a "latest" tag if necessary
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "Tagging images as latest to test"
            docker tag $BASE_IMAGE_NAME $BASE_IMAGE_ID:latest
            docker tag $INDEXER_IMAGE_NAME $INDEXER_IMAGE_ID:latest
            docker tag $NGINX_IMAGE_NAME $NGINX_IMAGE_ID:latest
          fi
          
          docker push $NGINX_IMAGE_ID:$VERSION
          docker push $BASE_IMAGE_ID:$VERSION
          docker push $INDEXER_IMAGE_ID:$VERSION

          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "Pushing latest images to test"
            docker push $NGINX_IMAGE_ID:latest
            docker push $BASE_IMAGE_ID:latest
            docker push $INDEXER_IMAGE_ID:latest
          fi
          
